<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Integrator by phuu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Integrator</h1>
      <h2 class="project-tagline">An experiment in fixing integration testing.</h2>
      <a href="https://github.com/phuu/integrator" class="btn">View on GitHub</a>
      <a href="https://github.com/phuu/integrator/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/phuu/integrator/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>Before we begin, you should know:</p>

<ul>
<li>This isn't ready for you to use</li>
<li>This might be crazy</li>
<li>
<em>Please</em> read everything below before trying to use integrator. It's... different.</li>
</ul>

<h2>
<a id="current-state" class="anchor" href="#current-state" aria-hidden="true"><span class="octicon octicon-link"></span></a>Current state</h2>

<p>I'm working on a suite of actions for TodoMVC. If you want to see how integrator looks in use right now, <a href="https://github.com/phuu/todomvc/blob/integrator/tests/integrator/actions.js">check that out</a>.</p>

<p>There are some big questions in my head:</p>

<ul>
<li>can the task runner component of integrator be broken out into its own thing? (build tooling, anyone?)</li>
<li>is this insane? does it scale? does it work?</li>
</ul>

<h2>
<a id="try-it-out" class="anchor" href="#try-it-out" aria-hidden="true"><span class="octicon octicon-link"></span></a>Try it out?</h2>

<p>Don't. You could check out the TodoMVC integrator branch, but it's likely broken and has 0 docs. However, <a href="https://github.com/phuu/integrator/issues/new">please tell me what you think of this idea</a>.</p>

<h2>
<a id="rationale" class="anchor" href="#rationale" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rationale</h2>

<p>There are numerous problems with integration tests today:</p>

<ul>
<li><p><em>They don't simulate users.</em> Only the user-flows that you thought to test are tested, and assertions are coupled to CSS selectors. That's is not how a user sees your application and it results in <a href="http://googletesting.blogspot.co.uk/2015/01/testing-on-toilet-change-detector-tests.html">change-detector</a> tests.</p></li>
<li><p><em>They have implicit dependencies.</em> Current test frameworks encourage (or don't dissuade, at least) you from writing tests that depend on another test having run, without making this explicit. The result is that test order <em>might be</em> important, which is hard to debug and refactor.</p></li>
<li><p><em>Tests are hard to write and debug.</em> This leads to flaky tests, false negatives or (worse) false positives, and untested but critical user flows.</p></li>
</ul>

<p>Fixing it requires taking some of the manual work out of creating and maintaining these tests, providing a framework that helps the test author to avoid writing bad tests.</p>

<p>What does that mean specifically?</p>

<ul>
<li>Explicit, reproducible setup &amp; teardown</li>
<li>Real user simulation

<ul>
<li>Chaotic testing</li>
<li>No CSS selectors!</li>
</ul>
</li>
<li>Explicit dependencies

<ul>
<li>Ordering is defined and deterministic</li>
</ul>
</li>
</ul>

<p><strong>Integrator</strong> is an experiment in fixing this. It's a test runner and authoring framework that tries to help.</p>

<h2>
<a id="concepts" class="anchor" href="#concepts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concepts</h2>

<h3>
<a id="actions" class="anchor" href="#actions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Actions</h3>

<p>Integrator is based around a <strong>suite</strong> of named <strong>actions</strong>. The suite is associated with a <strong>model</strong> that the actions use to track the work they've done.</p>

<h4>
<a id="phases" class="anchor" href="#phases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Phases</h4>

<p>Actions have four <strong>phases</strong>: <em>setup</em>, <em>assert</em>, <em>teardown</em> and <em>done</em>.</p>

<p>Each action should make some changes to the application (click buttons, type stuff, etc) and then assert that the changes were made successfully. They should be as <em>atomic as possible</em>, and all are <em>optional</em>.</p>

<p>While the phases can be used for anything, it will be better to use them consistently:</p>

<ul>
<li>
<em>setup</em> should do the work of the action, changing the application and updating the model</li>
<li>
<em>assert</em> should check that <em>setup</em> work was carried out successfully, and throw if it wasn't. Assertions should generally be made with comparisons between the <em>state of the page</em> and the <em>model</em>
</li>
<li>
<em>teardown</em> should undo any work done in setup that would otherwise prevent a user from carrying on their work (for example, closing a modal)</li>
<li>
<em>done</em> should check that <em>teardown</em> was carried out successfully, and throw if it wasn't</li>
</ul>

<p>It's going to take some time to figure out the correct usage of teardown, but currently my thinking is that you should:</p>

<ul>
<li>use teardown to undo anything that significantly changes the user's view of the application</li>
<li>don't undo changes to the application's data (instead, update the model and compare)</li>
</ul>

<h4>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h4>

<p>Actions can (should) specify that they are <em>dependent on other actions</em>.</p>

<p>Integrator figures out what actions it needs to run by looking at each action's dependencies, running actions in order such that a particular action's dependencies are <em>always run first</em>.</p>

<p>Actions that depend on each other <em>form a graph</em> that Integrator uses determine what to run when.</p>

<p>It can randomly choose actions from the graph, and moves from action-to-action in way that optimises for the <em>least amount of work</em>. It will not teardown anything that it doesn't need to. This mode of operation is is called a 'random walk'.</p>

<h4>
<a id="model" class="anchor" href="#model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model</h4>

<p>The model should reflect the state of the application being tested in a data structure. Actions should run assertions that <em>compare the expected state from the model against the UI of the application</em>.</p>

<p>Every phase function is passed current model and must return a Promise for the (possibly updated) model.</p>

<h4>
<a id="example-action" class="anchor" href="#example-action" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example action</h4>

<p>A simple action that opens a page and check that the title is correct might look like this:</p>

<div class="highlight highlight-js"><pre>Action(
    <span class="pl-c">// Name</span>
    <span class="pl-s"><span class="pl-pds">'</span>open Google<span class="pl-pds">'</span></span>,
    <span class="pl-c">// Dependencies</span>
    [],
    <span class="pl-c">// Phases</span>
    {
        setup<span class="pl-k">:</span> model <span class="pl-k">=&gt;</span>
            session.get(<span class="pl-s"><span class="pl-pds">'</span>https://google.com<span class="pl-pds">'</span></span>)
                .then(()<span class="pl-k"> =&gt;</span> model.set(<span class="pl-s"><span class="pl-pds">'</span>title<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Google<span class="pl-pds">'</span></span>)),

        assert<span class="pl-k">:</span> utils.makeEffect(model <span class="pl-k">=&gt;</span>
            session.getPageTitle()
                .then(title <span class="pl-k">=&gt;</span> {
                    assert.ok(
                        title.trim() <span class="pl-k">===</span> model.get(<span class="pl-s"><span class="pl-pds">'</span>title<span class="pl-pds">'</span></span>),
                        <span class="pl-s"><span class="pl-pds">'</span>Title is wrong<span class="pl-pds">'</span></span>
                    );
                }))
    }
);</pre></div>

<blockquote>
<p>The <code>utils.makeEffect</code> call that wraps the <code>assert</code> phase function means that the phase function has side-effects only, and does not modify the model. The function returned from <code>makeEffect</code> returns a Promise for the model.</p>
</blockquote>

<h4>
<a id="dependency-graph" class="anchor" href="#dependency-graph" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependency graph</h4>

<p>The dependencies of the actions that make up your test suite form a graph. When a particular action is run, Integrator:</p>

<ul>
<li>walks the graph to find all the dependencies up to the root(s) of the graph</li>
<li>figures out what actions it must run in what order</li>
<li>resolves the actions' <a href="#fixtures">fixtures</a>
</li>
<li>runs forward from the first dependency to the target action</li>
</ul>

<p>In the dependency list, <em>order is important</em>. Dependencies should be listed left-to-right in order of priority.</p>

<p>For example, imagine this graph (which happens to have a single root):</p>

<pre><code>     A
    / \
   B   C
  / \   \
 D   E - F
          \
           G
</code></pre>

<p>If we wanted to run <code>G</code>, the dependencies in order are <code>A, B, E, C, and F</code>. Action <code>F</code> would have dependencies <code>['E', 'C']</code>, so the <code>E</code> dependency path is more important (it comes first), and therefore is run before <code>C</code>.</p>

<h3>
<a id="model-1" class="anchor" href="#model-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model</h3>

<p>As mentioned above, a test suite is the combination of an action graph and a model. The model should be modified by action phases to track their expected changes to the application state.</p>

<p>For example, in a todo application the model would contain a list of todo items. In the assertion phases (<code>assert</code> and <code>done</code>), the model list would be checked against the list in real page, as the user sees it.</p>

<p>Since the model will change and grow over time, the assertions should be generic and flexible. This means, for example, that the todo list tests should compare the length and text of the complete list every time, rather than checking that a specific item has been added in a specific place. This also aids the reusability of the assertions.</p>

<p>The model can be any <code>immutable-js</code> data structure.</p>

<h3>
<a id="fixtures" class="anchor" href="#fixtures" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fixtures</h3>

<p>Actions can specify <em>fixtures</em>. A fixture in integrator is a named piece of data that the action will use when running. For example, this could be the user that a 'login' action will use, or the todos it should add.</p>

<p>Here's an example, where we specify a search query for Google.</p>

<div class="highlight highlight-js"><pre>Action(<span class="pl-s"><span class="pl-pds">'</span>fill in the search box<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>open Google<span class="pl-pds">'</span></span>], {
    fixtures<span class="pl-k">:</span> {
        query<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>integrator<span class="pl-pds">'</span></span>
    },

    setup<span class="pl-k">:</span> (<span class="pl-smi">model</span>, <span class="pl-smi">fixtures</span>)<span class="pl-k"> =&gt;</span>
        session.findByName(<span class="pl-s"><span class="pl-pds">'</span>q<span class="pl-pds">'</span></span>)
            <span class="pl-c">// Type the query into the search box</span>
            .then(elem <span class="pl-k">=&gt;</span> elem.<span class="pl-c1">type</span>(fixtures.get(<span class="pl-s"><span class="pl-pds">'</span>query<span class="pl-pds">'</span></span>)))
            <span class="pl-c">// Remember what we expect the the entered query to be</span>
            .then(()<span class="pl-k"> =&gt;</span> model.set(<span class="pl-s"><span class="pl-pds">'</span>query<span class="pl-pds">'</span></span>, fixtures.get(<span class="pl-s"><span class="pl-pds">'</span>query<span class="pl-pds">'</span></span>)))
});</pre></div>

<p>Fixtures can be values or functions that generate values.</p>

<div class="highlight highlight-js"><pre>fixtures<span class="pl-k">:</span> {
    query<span class="pl-k">:</span> ()<span class="pl-k"> =&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>integrator<span class="pl-pds">'</span></span>
}</pre></div>

<p>When an action is run, its fixtures and all the fixtures of its dependencies are bundled first — starting with the action to be run, and working back through its chain of dependencies. The actions are then run in the reverse of this order with every action being run against the same set of fixtures.</p>

<p>For example, two actions that specify different fixtures:</p>

<div class="highlight highlight-js"><pre>Action(<span class="pl-s"><span class="pl-pds">'</span>first<span class="pl-pds">'</span></span>, [], {
    fixtures<span class="pl-k">:</span> {
        a<span class="pl-k">:</span> <span class="pl-c1">10</span>
    }
})

Action(<span class="pl-s"><span class="pl-pds">'</span>second<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>first<span class="pl-pds">'</span></span>], {
    fixtures<span class="pl-k">:</span> {
        b<span class="pl-k">:</span> <span class="pl-c1">20</span>
    }
})</pre></div>

<p>When the <code>second</code> action runs, the fixtures will be an <code>immutable-js</code> Map containing <code>{ a: 10, b: 20 }</code>.</p>

<p>Aside: each action will only see the values for fixtures it has declared — 'first' will be parsed a map with key 'a', whereas 'second' will see only 'b'. This is to prevent implicit fixture dependencies.</p>

<h4>
<a id="pass-through-fixtures" class="anchor" href="#pass-through-fixtures" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pass-through fixtures</h4>

<p>If the fixture value is a function, the function will be passed any existing fixture value (from dependent actions), or undefined if there isn't a pre-existing value.</p>

<pre><code>Action('third', ['second'], {
    fixtures: {
        a: existingA =&gt; existingA
    }
})
</code></pre>

<p>This means that, since actions can specify the same fixtures, it's possible to have an action that doesn't care what value it gets, so long as it gets one, and falls back to a default value if there's nothing present.</p>

<div class="highlight highlight-js"><pre>Action(<span class="pl-s"><span class="pl-pds">'</span>fill in the search box<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>open Google<span class="pl-pds">'</span></span>], {
    fixtures<span class="pl-k">:</span> {
        query<span class="pl-k">:</span> query <span class="pl-k">=&gt;</span> (<span class="pl-k">typeof</span> query <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>undefined<span class="pl-pds">'</span></span> <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span>integrator<span class="pl-pds">'</span></span> <span class="pl-k">:</span> query)
    }
});</pre></div>

<p>This pattern allows variations of a given action by <em>simply changing the fixtures</em>.</p>

<div class="highlight highlight-js"><pre>Action(<span class="pl-s"><span class="pl-pds">'</span>type nothing into the search box<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>fill in the search box<span class="pl-pds">'</span></span>], {
    fixtures<span class="pl-k">:</span> {
        query<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>
    }
});

Action(<span class="pl-s"><span class="pl-pds">'</span>type a really long query into the search box<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>fill in the search box<span class="pl-pds">'</span></span>], {
    fixtures<span class="pl-k">:</span> {
        query<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>some really long string here!<span class="pl-pds">'</span></span>
    }
});</pre></div>

<h4>
<a id="fixtures-and-teardown" class="anchor" href="#fixtures-and-teardown" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fixtures and teardown</h4>

<p>Fixtures represent the data an action needs to carry out its work. Since the fixtures an action may receive can change (probably due to 'pass-through' usage), integrator considers the same action with different fixtures to effectively be a different action. During a random walk, if it needs to repeat an action (but with different fixtures), Integrator will run the action's teardown and done phases, then then setup and assert, to make sure that actions run with the correct fixtures.</p>

<p>For example, imagine actions <code>A</code>, <code>B</code> and <code>C</code>:</p>

<ul>
<li>
<code>A</code> doesn't have any fixtures</li>
<li>
<code>B</code> relies on fixture <code>x</code> with any value, defaulting to 1</li>
<li>
<code>C</code> relies on fixture <code>x</code> with value 2</li>
</ul>

<p>During a random walk, if integrator picks <code>B</code>, it will run <code>A</code> then <code>B</code> with fixtures <code>{ x: 1 }</code>.</p>

<p>If it then picked <code>C</code>, having just run <code>B</code>, it will reverse-out (teardown) <code>B</code> and run forward (setup) <code>C</code> with fixtures <code>{ x: 2 }</code>.</p>

<h2>
<a id="requirements" class="anchor" href="#requirements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements</h2>

<ul>
<li>
<a href="https://nodejs.org/">node</a> (or <a href="https://iojs.org">io.js</a>, probably) and <a href="https://www.npmjs.com/">npm</a>
</li>
</ul>

<p>Optionally, you might use the dockerised Selenium grid. Whatever happens, you need a selenium server.</p>

<ul>
<li><a href="https://www.docker.com/">docker</a></li>
<li><a href="https://docs.docker.com/compose/">docker-compose</a></li>
<li>I've been using <a href="https://docs.docker.com/machine/">docker-machine</a>
</li>
</ul>

<h2>
<a id="related-tools" class="anchor" href="#related-tools" aria-hidden="true"><span class="octicon octicon-link"></span></a>Related Tools</h2>

<ul>
<li>
<a href="https://github.com/phuu/integrator-match">integrator-match</a> — no more CSS selectors in integration tests. Also not ready yet.</li>
</ul>

<h3>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h3>

<p>MIT</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/phuu/integrator">Integrator</a> is maintained by <a href="https://github.com/phuu">phuu</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

