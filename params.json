{"name":"Integrator","tagline":"An experiment in fixing integration testing.","body":"Before we begin, you should know:\r\n\r\n- This isn't ready for you to use\r\n- This might be crazy\r\n- *Please* read everything below before trying to use integrator. It's... different.\r\n\r\n## Current state\r\n\r\nI'm working on a suite of actions for TodoMVC. If you want to see how integrator looks in use right now, [check that out][todomvc-actions].\r\n\r\nThere are some big questions in my head:\r\n\r\n- can the task runner component of integrator be broken out into its own thing? (build tooling, anyone?)\r\n- is this insane? does it scale? does it work?\r\n\r\n## Try it out?\r\n\r\nDon't. You could check out the TodoMVC integrator branch, but it's likely broken and has 0 docs. However, [please tell me what you think of this idea][new-issue].\r\n\r\n## Rationale\r\n\r\nThere are numerous problems with integration tests today:\r\n\r\n- *They don't simulate users.* Only the user-flows that you thought to test are tested, and assertions are coupled to CSS selectors. That's is not how a user sees your application and it results in [change-detector][change-detector] tests.\r\n\r\n- *They have implicit dependencies.* Current test frameworks encourage (or don't dissuade, at least) you from writing tests that depend on another test having run, without making this explicit. The result is that test order *might be* important, which is hard to debug and refactor.\r\n\r\n- *Tests are hard to write and debug.* This leads to flaky tests, false negatives or (worse) false positives, and untested but critical user flows.\r\n\r\nFixing it requires taking some of the manual work out of creating and maintaining these tests, providing a framework that helps the test author to avoid writing bad tests.\r\n\r\nWhat does that mean specifically?\r\n\r\n- Explicit, reproducible setup & teardown\r\n- Real user simulation\r\n    - Chaotic testing\r\n    - No CSS selectors!\r\n- Explicit dependencies\r\n    - Ordering is defined and deterministic\r\n\r\n**Integrator** is an experiment in fixing this. It's a test runner and authoring framework that tries to help.\r\n\r\n## Concepts\r\n\r\n### Actions\r\n\r\nIntegrator is based around a **suite** of named **actions**. The suite is associated with a **model** that the actions use to track the work they've done.\r\n\r\n#### Phases\r\n\r\nActions have four **phases**: *setup*, *assert*, *teardown* and *done*.\r\n\r\nEach action should make some changes to the application (click buttons, type stuff, etc) and then assert that the changes were made successfully. They should be as *atomic as possible*, and all are *optional*.\r\n\r\nWhile the phases can be used for anything, it will be better to use them consistently:\r\n\r\n- *setup* should do the work of the action, changing the application and updating the model\r\n- *assert* should check that *setup* work was carried out successfully, and throw if it wasn't. Assertions should generally be made with comparisons between the *state of the page* and the *model*\r\n- *teardown* should undo any work done in setup that would otherwise prevent a user from carrying on their work (for example, closing a modal)\r\n- *done* should check that *teardown* was carried out successfully, and throw if it wasn't\r\n\r\nIt's going to take some time to figure out the correct usage of teardown, but currently my thinking is that you should:\r\n\r\n- use teardown to undo anything that significantly changes the user's view of the application\r\n- don't undo changes to the application's data (instead, update the model and compare)\r\n\r\n#### Dependencies\r\n\r\nActions can (should) specify that they are *dependent on other actions*.\r\n\r\nIntegrator figures out what actions it needs to run by looking at each action's dependencies, running actions in order such that a particular action's dependencies are *always run first*.\r\n\r\nActions that depend on each other *form a graph* that Integrator uses determine what to run when.\r\n\r\nIt can randomly choose actions from the graph, and moves from action-to-action in way that optimises for the *least amount of work*. It will not teardown anything that it doesn't need to. This mode of operation is is called a 'random walk'.\r\n\r\n#### Model\r\n\r\nThe model should reflect the state of the application being tested in a data structure. Actions should run assertions that *compare the expected state from the model against the UI of the application*.\r\n\r\nEvery phase function is passed current model and must return a Promise for the (possibly updated) model.\r\n\r\n#### Example action\r\n\r\nA simple action that opens a page and check that the title is correct might look like this:\r\n\r\n```js\r\nAction(\r\n    // Name\r\n    'open Google',\r\n    // Dependencies\r\n    [],\r\n    // Phases\r\n    {\r\n        setup: model =>\r\n            session.get('https://google.com')\r\n                .then(() => model.set('title', 'Google')),\r\n\r\n        assert: utils.makeEffect(model =>\r\n            session.getPageTitle()\r\n                .then(title => {\r\n                    assert.ok(\r\n                        title.trim() === model.get('title'),\r\n                        'Title is wrong'\r\n                    );\r\n                }))\r\n    }\r\n);\r\n```\r\n\r\n> The `utils.makeEffect` call that wraps the `assert` phase function means that the phase function has side-effects only, and does not modify the model. The function returned from `makeEffect` returns a Promise for the model.\r\n\r\n#### Dependency graph\r\n\r\nThe dependencies of the actions that make up your test suite form a graph. When a particular action is run, Integrator:\r\n\r\n- walks the graph to find all the dependencies up to the root(s) of the graph\r\n- figures out what actions it must run in what order\r\n- resolves the actions' [fixtures](#fixtures)\r\n- runs forward from the first dependency to the target action\r\n\r\nIn the dependency list, *order is important*. Dependencies should be listed left-to-right in order of priority.\r\n\r\nFor example, imagine this graph (which happens to have a single root):\r\n\r\n```\r\n     A\r\n    / \\\r\n   B   C\r\n  / \\   \\\r\n D   E - F\r\n          \\\r\n           G\r\n```\r\n\r\nIf we wanted to run `G`, the dependencies in order are `A, B, E, C, and F`. Action `F` would have dependencies `['E', 'C']`, so the `E` dependency path is more important (it comes first), and therefore is run before `C`.\r\n\r\n### Model\r\n\r\nAs mentioned above, a test suite is the combination of an action graph and a model. The model should be modified by action phases to track their expected changes to the application state.\r\n\r\nFor example, in a todo application the model would contain a list of todo items. In the assertion phases (`assert` and `done`), the model list would be checked against the list in real page, as the user sees it.\r\n\r\nSince the model will change and grow over time, the assertions should be generic and flexible. This means, for example, that the todo list tests should compare the length and text of the complete list every time, rather than checking that a specific item has been added in a specific place. This also aids the reusability of the assertions.\r\n\r\nThe model can be any `immutable-js` data structure.\r\n\r\n### Fixtures\r\n\r\nActions can specify *fixtures*. A fixture in integrator is a named piece of data that the action will use when running. For example, this could be the user that a 'login' action will use, or the todos it should add.\r\n\r\nHere's an example, where we specify a search query for Google.\r\n\r\n```js\r\nAction('fill in the search box', ['open Google'], {\r\n    fixtures: {\r\n        query: 'integrator'\r\n    },\r\n\r\n    setup: (model, fixtures) =>\r\n        session.findByName('q')\r\n            // Type the query into the search box\r\n            .then(elem => elem.type(fixtures.get('query')))\r\n            // Remember what we expect the the entered query to be\r\n            .then(() => model.set('query', fixtures.get('query')))\r\n});\r\n```\r\n\r\nFixtures can be values or functions that generate values.\r\n\r\n```js\r\nfixtures: {\r\n    query: () => 'integrator'\r\n}\r\n```\r\n\r\nWhen an action is run, its fixtures and all the fixtures of its dependencies are bundled first — starting with the action to be run, and working back through its chain of dependencies. The actions are then run in the reverse of this order with every action being run against the same set of fixtures.\r\n\r\nFor example, two actions that specify different fixtures:\r\n\r\n```js\r\nAction('first', [], {\r\n    fixtures: {\r\n        a: 10\r\n    }\r\n})\r\n\r\nAction('second', ['first'], {\r\n    fixtures: {\r\n        b: 20\r\n    }\r\n})\r\n```\r\n\r\nWhen the `second` action runs, the fixtures will be an `immutable-js` Map containing `{ a: 10, b: 20 }`.\r\n\r\nAside: each action will only see the values for fixtures it has declared — 'first' will be parsed a map with key 'a', whereas 'second' will see only 'b'. This is to prevent implicit fixture dependencies.\r\n\r\n#### Pass-through fixtures\r\n\r\nIf the fixture value is a function, the function will be passed any existing fixture value (from dependent actions), or undefined if there isn't a pre-existing value.\r\n\r\n```\r\nAction('third', ['second'], {\r\n    fixtures: {\r\n        a: existingA => existingA\r\n    }\r\n})\r\n```\r\n\r\nThis means that, since actions can specify the same fixtures, it's possible to have an action that doesn't care what value it gets, so long as it gets one, and falls back to a default value if there's nothing present.\r\n\r\n```js\r\nAction('fill in the search box', ['open Google'], {\r\n    fixtures: {\r\n        query: query => (typeof query === 'undefined' ? 'integrator' : query)\r\n    }\r\n});\r\n```\r\n\r\nThis pattern allows variations of a given action by *simply changing the fixtures*.\r\n\r\n```js\r\nAction('type nothing into the search box', ['fill in the search box'], {\r\n    fixtures: {\r\n        query: ''\r\n    }\r\n});\r\n\r\nAction('type a really long query into the search box', ['fill in the search box'], {\r\n    fixtures: {\r\n        query: 'some really long string here!'\r\n    }\r\n});\r\n```\r\n\r\n#### Fixtures and teardown\r\n\r\nFixtures represent the data an action needs to carry out its work. Since the fixtures an action may receive can change (probably due to 'pass-through' usage), integrator considers the same action with different fixtures to effectively be a different action. During a random walk, if it needs to repeat an action (but with different fixtures), Integrator will run the action's teardown and done phases, then then setup and assert, to make sure that actions run with the correct fixtures.\r\n\r\nFor example, imagine actions `A`, `B` and `C`:\r\n\r\n- `A` doesn't have any fixtures\r\n- `B` relies on fixture `x` with any value, defaulting to 1\r\n- `C` relies on fixture `x` with value 2\r\n\r\nDuring a random walk, if integrator picks `B`, it will run `A` then `B` with fixtures `{ x: 1 }`.\r\n\r\nIf it then picked `C`, having just run `B`, it will reverse-out (teardown) `B` and run forward (setup) `C` with fixtures `{ x: 2 }`.\r\n\r\n## Requirements\r\n\r\n- [node](https://nodejs.org/) (or [io.js](https://iojs.org), probably) and [npm][npm]\r\n\r\nOptionally, you might use the dockerised Selenium grid. Whatever happens, you need a selenium server.\r\n\r\n- [docker](https://www.docker.com/)\r\n- [docker-compose](https://docs.docker.com/compose/)\r\n- I've been using [docker-machine](https://docs.docker.com/machine/)\r\n\r\n## Related Tools\r\n\r\n- [integrator-match](https://github.com/phuu/integrator-match) — no more CSS selectors in integration tests. Also not ready yet.\r\n\r\n### License\r\n\r\nMIT\r\n\r\n[change-detector]: http://googletesting.blogspot.co.uk/2015/01/testing-on-toilet-change-detector-tests.html\r\n[npm]: https://www.npmjs.com/\r\n[todomvc-actions]: https://github.com/phuu/todomvc/blob/integrator/tests/integrator/actions.js\r\n[new-issue]: https://github.com/phuu/integrator/issues/new\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}